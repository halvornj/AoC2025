* day 1
Game plan:
1. make a function like: (func current_num, score_count) 
2. start current_num at 50, score_count at 0
3. for each line:
   eval "R->plus", "L->minus"
   eval new current_num
   call same function, with (func new_current_num, (if (= (modulo new_current_num 100) 0) (+ 1 score_count) score_count)

This function will be used to read the input-file, probably for all solutions...
** TODO i should figure out how to export this to a folder-level? library
#+BEGIN_SRC elisp
  (defun get-input ()
    "Return a list of lines of a file at ./input."
    (with-temp-buffer
      (insert-file-contents "test_input")
      (split-string (buffer-string) "\n" t)))
#+END_SRC

#+RESULTS:
: get-input

** helper functions
#+BEGIN_SRC elisp
  (defun get-direction (str)
    (if (eq (aref str 0) ?L) ;;if the first char is L, return the minus-function. else, return plus-function
	'- '+))
  (defun get-clicks (str)
    (string-to-number (substring str 1 (length str)))) ;; that 3 is going to be a problem for things like L1

  (defun n-rotate (start_num str)
    (funcall (get-direction str) start_num (get-clicks str)))
#+END_SRC

#+RESULTS:
: n-rotate

*** testing the helpers
who needs unit tests, when you have interactive evaluation buffers:
#+BEGIN_SRC elisp

  (n-rotate 5500 "L68")
#+END_SRC

#+RESULTS:
: 5432

** solution:
#+BEGIN_SRC elisp
  (defun count-zero-visits (l current_num score_count)
    (if (null l) score_count
     (count-zero-visits (cdr l)
			(n-rotate current_num (car l))
			(if (eq (mod (n-rotate current_num (car l)) 100)  0)
			    (+ score_count 1) score_count))))

  (count-zero-visits (get-input) 5000 0)
#+END_SRC

#+RESULTS:
: 0


** TODO set this as part of the project, or default
#+BEGIN_SRC elisp
(setq max-lisp-eval-depth 10000)
#+END_SRC

#+RESULTS:
: 10000



* Part two
I hope this works:
What if, instead of just checking if mod equals 0, we also do some floor division,
eg dial is at 1752, and 100 goes 17 times into dial.
Then, we rotate to 1680 - 100 goes 16 times - we've crossed a boundary. we add 1 to score.


** helper functions
#+BEGIN_SRC elisp
  (defun passes-hundred (old-num new-num)
  	       (not (equal (truncate (/ new-num 100))
      				    (truncate (/ old-num 100)))))
  (defun passes-zero (old-num new-num)
    (if (equal  old-num 0) nil
    (not (equal (natnump old-num) (natnump new-num)))))
#+END_SRC

#+RESULTS:
: passes-zero

** tests
#+BEGIN_SRC elisp
  (passes-hundred 0 -1)
  (passes-zero 0 -1)
  
#+END_SRC

#+RESULTS:

** solution
#+BEGIN_SRC elisp
  (defun count-zero-passes (l current_num score_count)
        (if (null l) score_count
         (count-zero-passes (cdr l)
      			(n-rotate current_num (car l))
      			(if (or (equal (mod (n-rotate current_num (car l)) 100)  0)
      				(passes-hundred current_num (n-rotate current_num (car l)))
;  				(passes-zero current_num (n-rotate current_num (car l))))
      			    (+ score_count 1) score_count))))

      (count-zero-passes (get-input) 5000 0)
#+END_SRC

#+RESULTS:
: 5

