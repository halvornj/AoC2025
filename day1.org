* day 1
Game plan:
1. make a function like: (func current_num, score_count) 
2. start current_num at 50, score_count at 0
3. for each line:
   eval "R->plus", "L->minus"
   eval new current_num
   call same function, with (func new_current_num, (if (= (modulo new_current_num 100) 0) (+ 1 score_count) score_count)

This function will be used to read the input-file, probably for all solutions...
** TODO i should figure out how to export this to a folder-level? library
#+BEGIN_SRC elisp
  (defun get-input ()
    "Return a list of lines of a file at ./input."
    (with-temp-buffer
      (insert-file-contents "input")
      (split-string (buffer-string) "\n" t)))
#+END_SRC

#+RESULTS:
: get-input

** helper functions
#+BEGIN_SRC elisp
  (defun padded-str (str)
    (if (< (length str) 3)
	(string (aref str 0) ?0 (aref str 1))
      str))

  (defun get-direction (str)
    (if (eq (aref str 0) ?L) ;;if the first char is L, return the minus-function. else, return plus-function
	'- '+))
  (defun get-clicks (str)
    (string-to-number (substring (padded-str str) 1 3))) ;; that 3 is going to be a problem for things like L1

  (defun n-rotate (start_num str)
    (funcall (get-direction str) start_num (get_clicks str)))
#+END_SRC

#+RESULTS:
: n-rotate

*** testing the helpers
who needs unit tests, when you have interactive evaluation buffers:
#+BEGIN_SRC elisp
  (n-rotate 50 "L40")
#+END_SRC

#+RESULTS:
: 41

** Beginning the actual solution:
#+BEGIN_SRC elisp
  (defun count-zero-visits (l current_num score_count)
    (if (null l) score_count
     (count-zero-visits (cdr l)
			(n-rotate current_num (car l))
			(if (= (mod 100 (n-rotate current_num (car l)))  0)
			    (+ score_count 1) score_count))))

  (count-zero-visits (get-input))
#+END_SRC

#+RESULTS:
| L68 | L30 | R48 | L5 | R60 | L55 | L1 | L99 | R14 | L82 |
