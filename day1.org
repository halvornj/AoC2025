* day 1
Game plan:
1. make a function like: (func current_num, score_count) 
2. start current_num at 50, score_count at 0
3. for each line:
   eval "R->plus", "L->minus"
   eval new current_num
   call same function, with (func new_current_num, (if (= (modulo new_current_num 100) 0) (+ 1 score_count) score_count)

This function will be used to read the input-file, probably for all solutions...
** TODO i should figure out how to export this to a folder-level? library
#+BEGIN_SRC elisp
  (defun get-input ()
    "Return a list of lines of a file at ./input."
    (with-temp-buffer
      (insert-file-contents "input")
      (split-string (buffer-string) "\n" t)))
#+END_SRC

#+RESULTS:
: get-input

** helper functions
#+BEGIN_SRC elisp
  (defun padded-str (str)
    (if (< (length str) 3)
        (string (aref str 0) ?0 (aref str 1))
      str))
    
  (defun get-direction (str)
    (if (eq (aref str 0) ?L) ;;if the first char is L, return the minus-function. else, return plus-function
        - +))
  (defun get-clicks (str)
    (string-to-number (substring str 1 3))) ;; that 3 is going to be a problem for things like L1
#+END_SRC

#+RESULTS:
: get-clicks

*** testing the helpers
who needs unit tests, when you have interactive evaluation buffers:
#+BEGIN_SRC elisp
;;  (get-direction "R13")
  (get-clicks (padded-str "R41"))
#+END_SRC

#+RESULTS:
: 41

** Beginning the actual solution:
#+BEGIN_SRC elisp
  (defun count-zero-visits (l, current_num, score_count)
    (cond
     ((null l) score_count)
     (
#+END_SRC

#+RESULTS:
| L68 | L30 | R48 | L5 | R60 | L55 | L1 | L99 | R14 | L82 |
